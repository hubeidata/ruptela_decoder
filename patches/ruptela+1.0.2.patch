diff --git a/node_modules/ruptela/lib/index.js b/node_modules/ruptela/lib/index.js
index 83177ec..81186ed 100644
--- a/node_modules/ruptela/lib/index.js
+++ b/node_modules/ruptela/lib/index.js
@@ -1,77 +1,81 @@
-'use strict';
+const Iterator = require('./iterator');
 
-/**
- * Module dependencies
- */
-const Base = require('./base'),
-        Commander = require('./commander'),
-        Crc = require('./crc'),
-        Iterator = require('./iterator');
+function parse(buffer) {
+  const iterator = new Iterator(buffer);
+  const records = [];
 
-/**
- * Process buffer
- * 
- * @param {Buffer} buffer
- * @returns {Object}
- */
-function process(buffer) {
-    //set buffer iterator
-    const bufIt = new Iterator(buffer);
-    const bufEnd = bufIt.end;
-    //get base
-    const base = new Base();
-    if (base.fieldsLength > bufEnd) {
-        throw new Error("Buffer size is too small");
-    }
-    //get base fields
-    const fields = base.fields;
-    //read CRC, last 2 bytes from buffer
-    const crc = bufIt.buffer.readUIntBE(bufEnd - fields.crc, fields.crc);
-    //slice first and last 2 bytes from buffer
-    const tmpBuffer = bufIt.buffer.slice(fields.packet_length, -fields.crc);
-    //compare CRC codes (read with calculated)
-    if (crc !== Crc.calculate(tmpBuffer)) {
-        throw new Error("CRC is not valid");
-    }
-    //init data
-    const data = {};
-    //read packet length
-    data.packet_length = bufIt.readNext(fields.packet_length);
-    if (data.packet_length !== (bufEnd - fields.packet_length - fields.crc)) {
-        throw new Error("Packet Length is not valid");
+  while (iterator.hasNext()) {
+    try {
+      const record = processRecord(iterator);
+      records.push(record);
+    } catch (error) {
+      iterator.emit('error', error);
+      break;
     }
-    //read IMEI
-    data.imei = bufIt.readNext(fields.imei);
-    //read command ID
-    data.command_id = bufIt.readNext(fields.command_id);
-    //execute command
-    const commander = new Commander(data.command_id);
-    commander.command.execute(bufIt);
-    //assign command data to payload
-    data.payload = commander.command.data;
-    //assign CRC as last field
-    data.crc = crc;
-    //return data and acknowledgement
-    return {data, ack: commander.command.ack};
+  }
+
+  return records;
 }
 
-/**
- * Process buffer
- * 
- * @param {Buffer} buffer
- * @returns {Object}
- */
-function main(buffer) {
-    try {
-        //Process buffer and return object containing data and acknowledgement
-        return process(buffer);
-    } catch (error) {
-        //Return Error object
-        return {error: error};
+function processRecord(iterator) {
+  const startPosition = iterator.position;
+
+  // Parsear header
+  const header = {
+    timestamp: iterator.readNext(4),
+    timestampExtension: iterator.readNext(1),
+    recordExtension: iterator.readNext(1),
+    priority: iterator.readNext(1),
+    longitude: iterator.readNext(4),
+    latitude: iterator.readNext(4),
+    altitude: iterator.readNext(2),
+    angle: iterator.readNext(2),
+    satellites: iterator.readNext(1),
+    speed: iterator.readNext(2),
+    hdop: iterator.readNext(1),
+    eventId: iterator.readNext(2)
+  };
+
+  // Procesar elementos IO
+  const ioElements = [];
+  while (iterator.hasNext()) {
+    const valueSize = iterator.readNext(1);
+    const numberOfElements = iterator.readNext(1);
+
+    if (![1, 2, 4, 8].includes(valueSize)) {
+      throw new Error(`Tama침o de valor IO no soportado: ${valueSize}`);
     }
+
+    for (let i = 0; i < numberOfElements; i++) {
+      const element = {
+        id: iterator.readNext(2),
+        value: valueSize === 8 ? 
+          Number(iterator.readNext(8)) : // Conversi칩n BigInt a Number
+          iterator.readNext(valueSize)
+      };
+      ioElements.push(element);
+    }
+  }
+
+  // Retornar objeto con estructura corregida
+  return {
+    header: {
+      timestamp: header.timestamp,
+      timestampExtension: header.timestampExtension,
+      recordExtension: header.recordExtension,
+      priority: header.priority,
+      longitude: header.longitude / 10000000,
+      latitude: header.latitude / 10000000,
+      altitude: header.altitude / 10,
+      angle: header.angle / 100,
+      satellites: header.satellites,
+      speed: header.speed / 10,
+      hdop: header.hdop / 10,
+      eventId: header.eventId
+    },
+    ioElements: ioElements,
+    rawLength: iterator.position - startPosition
+  };
 }
 
-/**
- * Expose main function
- */
-module.exports = main;
\ No newline at end of file
+module.exports = { parse };
\ No newline at end of file
diff --git a/node_modules/ruptela/lib/iterator.js b/node_modules/ruptela/lib/iterator.js
index 926f427..105ae59 100644
--- a/node_modules/ruptela/lib/iterator.js
+++ b/node_modules/ruptela/lib/iterator.js
@@ -1,69 +1,54 @@
-'use strict';
+const { EventEmitter } = require('events');
+
+class Iterator extends EventEmitter {
+  constructor(buffer) {
+    super();
+    this.buffer = buffer;
+    this.position = 0;
+  }
+
+  readNext(byteLength) {
+    // Validaci칩n extendida para 8 bytes
+    if (byteLength < 1 || byteLength > 8) {
+      throw new Error(`Invalid byte length: ${byteLength}`);
+    }
 
-let buffer, offset;
+    if (this.position + byteLength > this.buffer.length) {
+      throw new Error('Buffer underflow');
+    }
 
-/**
- * This class iterates through buffer
- */
-class Iterator {
+    let value;
     
-    /**
-     * Set buffer
-     * 
-     * @param {Buffer} buf
-     */
-    constructor(buf) {
-        //check if buffer is truly a buffer
-        if (!Buffer.isBuffer(buf)) {
-            throw new Error("Input must be an instance of Buffer");
-        }
-        //set buffer
-        buffer = buf;
-        offset = 0;
+    // Lectura de 8 bytes (Big Endian)
+    if (byteLength === 8) {
+      value = this.buffer.readBigUInt64BE(this.position);
+    } else {
+      value = this.buffer.readUIntBE(this.position, byteLength);
     }
 
-    /**
-     * Get buffer
-     */
-    get buffer() {
-        return buffer;
-    }
+    this.position += byteLength;
     
-    /**
-     * Get offset
-     */
-    get offset() {
-        return offset;
-    }
+    // Conversi칩n de BigInt a Number para compatibilidad
+    return typeof value === 'bigint' ? Number(value) : value;
+  }
 
-    /**
-     * Get end of buffer
-     */
-    get end() {
-        return buffer.length;
+  readBytes(byteLength) {
+    if (this.position + byteLength > this.buffer.length) {
+      throw new Error('Buffer underflow');
     }
 
-    /**
-     * Reads byteLength number of bytes from buffer at the specified offset 
-     * and interprets the result as an (unsigned) integer
-     * 
-     * @param {int} byteLength
-     * @param {boolean} unsigned
-     * @returns {int}
-     */
-    readNext(byteLength, unsigned = true) {
-        const tmpOffset = offset;
-        offset += byteLength;
-        //check if an unsigned integer should be returned
-        if (unsigned === true) {
-            return buffer.readUIntBE(tmpOffset, byteLength);
-        }
-        return buffer.readIntBE(tmpOffset, byteLength);
-    }
+    const value = this.buffer.subarray(
+      this.position,
+      this.position + byteLength
+    );
+    
+    this.position += byteLength;
+    return value;
+  }
 
+  hasNext() {
+    return this.position < this.buffer.length;
+  }
 }
 
-/**
- * Expose class
- */
 module.exports = Iterator;
\ No newline at end of file
