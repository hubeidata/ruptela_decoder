const Iterator = require('./iterator');

function parse(buffer) {
  const iterator = new Iterator(buffer);
  const records = [];

  while (iterator.hasNext()) {
    try {
      const record = processRecord(iterator);
      records.push(record);
    } catch (error) {
      iterator.emit('error', error);
      break;
    }
  }

  return records;
}

function processRecord(iterator) {
  const startPosition = iterator.position;

  // Parsear header
  const header = {
    timestamp: iterator.readNext(4),
    timestampExtension: iterator.readNext(1),
    recordExtension: iterator.readNext(1),
    priority: iterator.readNext(1),
    longitude: iterator.readNext(4),
    latitude: iterator.readNext(4),
    altitude: iterator.readNext(2),
    angle: iterator.readNext(2),
    satellites: iterator.readNext(1),
    speed: iterator.readNext(2),
    hdop: iterator.readNext(1),
    eventId: iterator.readNext(2)
  };

  // Aplicar conversiones según especificación
  const processedRecord = {
    header: {
      ...header,
      longitude: header.longitude / 10000000,
      latitude: header.latitude / 10000000,
      altitude: header.altitude / 10,
      angle: header.angle / 100,
      speed: header.speed / 10,
      hdop: header.hdop / 10
    },
    ioElements: [],
    rawLength: 0 // Se actualizará al final
  };

  // Parsear cuerpo (IO Elements)
  while (iterator.hasNext()) {
    const valueSize = iterator.readNext(1);
    const elementCount = iterator.readNext(1);

    for (let i = 0; i < elementCount; i++) {
      const element = {
        id: iterator.readNext(2),
        value: null
      };

      switch (valueSize) {
        case 1:
          element.value = iterator.readNext(1);
          break;
        case 2:
          element.value = iterator.readNext(2);
          break;
        case 4:
          element.value = iterator.readNext(4);
          break;
        case 8:
          element.value = Number(iterator.readNext(8)); // BigInt a Number
          break;
        default:
          throw new Error(`Tamaño de valor IO no soportado: ${valueSize}`);
      }

      processedRecord.ioElements.push(element);
    }
  }

  // Calcular longitud procesada
  processedRecord.rawLength = iterator.position - startPosition;

  return processedRecord;
}

module.exports = { parse };