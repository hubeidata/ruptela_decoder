const Iterator = require('./iterator');

function parse(buffer) {
  const iterator = new Iterator(buffer);
  const records = [];

  while (iterator.hasNext()) {
    try {
      const record = processExtendedRecord(iterator);
      records.push(record);
    } catch (error) {
      iterator.emit('error', error);
      break;
    }
  }

  return records;
}

/**
 * Procesa un registro completo, uniendo todos sus fragmentos.
 */
function processExtendedRecord(iterator) {
  // Leer el primer fragmento
  const { header, ioElements, totalFragments, thisFragment } = readOneFragment(iterator);
  const allIO = [...ioElements];

  // Si hay más fragmentos, los concatenamos
  for (let frag = thisFragment + 1; frag < totalFragments; frag++) {
    const { ioElements: moreIO } = readOneFragment(iterator);
    allIO.push(...moreIO);
  }

  // Construir y devolver el registro unificado
  return {
    header: {
      timestamp:           header.timestamp,
      timestampExtension:  header.timestampExtension,
      recordExtension:     header.recordExtension,
      priority:            header.priority,
      longitude:           header.longitude  / 1e7,
      latitude:            header.latitude   / 1e7,
      altitude:            header.altitude   / 10,
      angle:               header.angle      / 100,
      satellites:          header.satellites,
      speed:               header.speed      / 10,
      hdop:                header.hdop       / 10,
      eventId:             header.eventId
    },
    ioElements: allIO
  };
}

/**
 * Lee un único fragmento (header + su parte de IO) y devuelve:
 *  - header completo
 *  - ioElements de este fragmento
 *  - totalFragments: m+1 del BCD alto de recordExtension
 *  - thisFragment: n (BCD bajo)
 */
function readOneFragment(iterator) {
  // Header fijo de 25 bytes
  const header = {
    timestamp:          iterator.readNext(4),
    timestampExtension: iterator.readNext(1),
    recordExtension:    iterator.readNext(1),
    priority:           iterator.readNext(1),
    longitude:          iterator.readNext(4),
    latitude:           iterator.readNext(4),
    altitude:           iterator.readNext(2),
    angle:              iterator.readNext(2),
    satellites:         iterator.readNext(1),
    speed:              iterator.readNext(2),
    hdop:               iterator.readNext(1),
    eventId:            iterator.readNext(2)
  };

  // Decodificar BCD mn de recordExtension
  const ext = header.recordExtension;
  const totalFragments = ((ext & 0xF0) >> 4) + 1;
  const thisFragment  =  (ext & 0x0F);

  // Body: IO elements
  const ioElements = [];

  // 1-byte values
  const cnt1 = iterator.readNext(1);
  for (let i = 0; i < cnt1; i++) {
    const id    = iterator.readNext(2);
    const value = iterator.readNext(1);
    ioElements.push({ id, value });
  }

  // 2-byte values
  const cnt2 = iterator.readNext(1);
  for (let i = 0; i < cnt2; i++) {
    const id    = iterator.readNext(2);
    const value = iterator.readNext(2);
    ioElements.push({ id, value });
  }

  // 4-byte values
  const cnt4 = iterator.readNext(1);
  for (let i = 0; i < cnt4; i++) {
    const id    = iterator.readNext(2);
    const value = iterator.readNext(4);
    ioElements.push({ id, value });
  }

  // 8-byte values
  const cnt8 = iterator.readNext(1);
  for (let i = 0; i < cnt8; i++) {
    const raw   = iterator.readNext(8);
    const id    = iterator.readNext(2);
    const value = typeof raw === 'bigint' ? Number(raw) : raw;
    ioElements.push({ id, value });
  }

  return { header, ioElements, totalFragments, thisFragment };
}

module.exports = { parse };
