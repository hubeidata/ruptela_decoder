const Iterator = require('./iterator');

function parse(buffer) {
  const iterator = new Iterator(buffer);
  const records = [];

  while (iterator.hasNext()) {
    try {
      const record = processRecord(iterator);
      records.push(record);
    } catch (error) {
      iterator.emit('error', error);
    }
  }

  return records;
}

function processRecord(iterator) {
  const header = {
    timestamp: iterator.readNext(4),
    timestampExtension: iterator.readNext(1),
    recordExtension: iterator.readNext(1),
    priority: iterator.readNext(1),
    longitude: iterator.readNext(4),
    latitude: iterator.readNext(4),
    altitude: iterator.readNext(2),
    angle: iterator.readNext(2),
    satellites: iterator.readNext(1),
    speed: iterator.readNext(2),
    hdop: iterator.readNext(1),
    eventId: iterator.readNext(2)
  };

  // Convertir valores según especificación del protocolo
  const record = {
    header: {
      ...header,
      longitude: header.longitude / 10000000,
      latitude: header.latitude / 10000000,
      altitude: header.altitude / 10,
      angle: header.angle / 100,
      speed: header.speed / 10,
      hdop: header.hdop / 10
    },
    ioElements: []
  };

  // Procesar elementos IO del cuerpo
  while (iterator.hasNext()) {
    const valueSize = iterator.readNext(1);
    const numberOfElements = iterator.readNext(1);

    for (let i = 0; i < numberOfElements; i++) {
      const element = {
        id: iterator.readNext(2), // IO ID de 2 bytes (big endian)
        value: null
      };

      // Manejar diferentes tamaños de valores
      switch (valueSize) {
        case 1:
          element.value = iterator.readNext(1);
          break;
        case 2:
          element.value = iterator.readNext(2);
          break;
        case 4:
          element.value = iterator.readNext(4);
          break;
        case 8: // Nuevo caso para 8 bytes
          const bigValue = iterator.readNext(8);
          element.value = Number(bigValue); // Convertir BigInt a Number
          break;
        default:
          throw new Error(`Tamaño de valor IO no soportado: ${valueSize}`);
      }

      record.ioElements.push(element);
    }
  }

  return record;
}

module.exports = { parse };